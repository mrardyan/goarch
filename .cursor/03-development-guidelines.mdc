---
alwaysApply: true
---

# Development Guidelines

## Code Style and Conventions

### 1. Naming Conventions

#### Packages
- Use lowercase, single word
- Avoid underscores or mixed case
- Be descriptive but concise

```go
// ✅ GOOD
package user
package auth
package config

// ❌ BAD
package UserService
package user_service
package userService
```

#### Files
- Use snake_case for file names
- Be descriptive and indicate purpose

```go
// ✅ GOOD
user_repository.go
auth_middleware.go
config_database.go

// ❌ BAD
userRepo.go
authMiddleware.go
configDB.go
```

#### Functions
- Use camelCase, descriptive names
- Use verb-noun format for actions
- Be clear about what the function does

```go
// ✅ GOOD
func CreateUser(ctx context.Context, user *User) error
func GetUserByID(ctx context.Context, id string) (*User, error)
func ValidateEmail(email string) error

// ❌ BAD
func create(ctx context.Context, u *User) error
func getUser(ctx context.Context, id string) (*User, error)
func validate(e string) error
```

#### Variables
- Use camelCase, descriptive names
- Avoid single letter variables (except in loops)
- Use meaningful names that indicate purpose

```go
// ✅ GOOD
userID := "123"
emailAddress := "user@example.com"
maxRetries := 3

// ❌ BAD
id := "123"
email := "user@example.com"
retries := 3
```

#### Constants
- Use UPPER_SNAKE_CASE
- Group related constants together

```go
// ✅ GOOD
const (
    MaxRetries = 3
    DefaultTimeout = 30 * time.Second
    CacheTTL = 5 * time.Minute
)
```

#### Interfaces
- Use descriptive names ending with -er
- Indicate the capability or behavior

```go
// ✅ GOOD
type UserRepository interface { ... }
type EmailService interface { ... }
type Logger interface { ... }

// ❌ BAD
type UserRepo interface { ... }
type Email interface { ... }
type Log interface { ... }
```

#### Structs
- Use PascalCase, descriptive names
- Indicate the purpose or domain concept

```go
// ✅ GOOD
type User struct { ... }
type CreateUserRequest struct { ... }
type DatabaseConfig struct { ... }

// ❌ BAD
type user struct { ... }
type createUserReq struct { ... }
type dbConfig struct { ... }
```

### 2. File Organization

#### Service Structure
Each service follows an enhanced layered architecture with CQRS support:

```
{service-name}/
├── domain/                    # Pure business rules
│   ├── entity/                # Core entities (Account, Role, etc)
│   ├── repository/            # Abstract interfaces (ports)
│   ├── service/               # Domain service logic (pure functions)
│   └── types/                 # Value objects, enums, primitives
│
├── application/              # Use case orchestration (commands/queries)
│   ├── {subdomain}/          # E.g. account/, role/, etc
│       ├── command.go
│       ├── query.go
│       └── dto.go
│
├── delivery/                 # Controller / handler layer
│   └── http/                 # HTTP handlers & routing
│       ├── handler.go
│       ├── router.go
│       └── middleware.go
│
├── infrastructure/           # Adapter layer (DB, cache, etc)
│   ├── postgres/             # DB repositories
│   ├── redis/                # Cache layer
│   ├── emailservice/         # External service clients
│   └── persistence.go        # Optional DB setup logic
│
├── config/                   # Service-specific config structures
│   └── config.go
│
├── init/                     # Service initialization logic (DI wiring)
│   └── init.go
│
└── module.go                 # Optional facade to expose
```

#### Package Organization
- Keep related code together
- Use meaningful package names
- Avoid circular dependencies
- Keep functions small and focused

### 3. Error Handling

#### Error Types
- Use structured errors with context
- Return errors from lower layers
- Log errors at the delivery layer
- Use custom error types for domain errors

```go
// ✅ GOOD: Custom domain error
type UserNotFoundError struct {
    UserID string
}

func (e UserNotFoundError) Error() string {
    return fmt.Sprintf("user not found: %s", e.UserID)
}

// ✅ GOOD: Error wrapping
if err != nil {
    return fmt.Errorf("failed to create user: %w", err)
}
```

#### Error Checking
- Always check errors and handle them appropriately
- Don't ignore errors
- Provide meaningful error messages

```go
// ✅ GOOD
user, err := repo.GetUser(ctx, userID)
if err != nil {
    return fmt.Errorf("failed to get user %s: %w", userID, err)
}

// ❌ BAD
user, _ := repo.GetUser(ctx, userID)
```

### 4. Logging

#### Structured Logging
Use structured logging with context:

```go
// ✅ GOOD
logger.Info("User created",
    zap.String("user_id", user.ID),
    zap.String("email", user.Email),
    zap.String("method", "CreateUser"),
)

logger.Error("Failed to create user",
    zap.String("user_id", userID),
    zap.Error(err),
    zap.String("method", "CreateUser"),
)
```

#### Log Levels
- **DEBUG**: Detailed information for debugging
- **INFO**: General information about application flow
- **WARN**: Warning messages for potential issues
- **ERROR**: Error messages for actual problems
- **FATAL**: Critical errors that require immediate attention

### 5. Configuration

#### Configuration Management
- Use Viper for configuration management
- Support multiple config sources (env vars, files, etc.)
- Use environment-specific config files
- Validate configuration on startup

```go
// ✅ GOOD: Configuration structure
type Config struct {
    Database DatabaseConfig `mapstructure:"database"`
    Server   ServerConfig   `mapstructure:"server"`
    Redis    RedisConfig    `mapstructure:"redis"`
}

type DatabaseConfig struct {
    Host     string `mapstructure:"host"`
    Port     int    `mapstructure:"port"`
    Username string `mapstructure:"username"`
    Password string `mapstructure:"password"`
    Database string `mapstructure:"database"`
}
```

### 6. Dependency Injection

#### DI Container Usage
- Use the bootstrap container for DI
- Register services in the container
- Use interfaces for dependencies
- Make testing easier with DI

```go
// ✅ GOOD: Service registration
container.Register("userRepository", func() UserRepository {
    return NewPostgreSQLUserRepository(db)
})

container.Register("userService", func() UserService {
    repo := container.Get("userRepository").(UserRepository)
    return NewUserService(repo)
})
```

## Development Guidelines

### 1. Service Creation
When creating a new service:
1. Use the template script: `./scripts/create.sh service <service-name>`
2. Follow the enhanced layered architecture pattern with CQRS support
3. Start with domain entities and business rules
4. Add application layer with commands and queries
5. Implement infrastructure layer (database, external APIs)
6. Add delivery layer (HTTP handlers, gRPC services)

#### Creating Subdomains
To add a new subdomain to an existing service:
```bash
./scripts/create.sh subdomain <subdomain-name> <service-name>
```

This will create:
- `application/{subdomain}/command.go`
- `application/{subdomain}/query.go`
- `application/{subdomain}/dto.go`

### 2. Testing Strategy
- **Unit Tests**: Test each layer independently with mocks
- **Integration Tests**: Test service interactions with test database
- **Performance Tests**: Use benchmarks for critical paths
- **Coverage**: Aim for 80%+ test coverage

### 3. Database
- Use PostgreSQL as primary database
- Use migrations for schema changes
- Follow naming conventions for tables and columns
- Use transactions for data consistency
- Implement proper indexing strategies

### 4. API Design
- Use RESTful principles
- Version APIs properly (/api/v1/)
- Use consistent error responses
- Implement proper validation
- Add comprehensive documentation

## Common Commands

### Development
```bash
# Setup environment
make setup

# Build application
make build

# Run main server
make run

# Run worker
make run-worker

# Run tests
make test

# Create new service
make create-service NAME=user-service
```

### Docker
```bash
# Build and run with Docker
make docker-build
make docker-run

# Development environment
make dev
make dev-stop
```

### Database
```bash
# Run migrations
make migrate-up
make migrate-down

# Create new migration
make migrate-create NAME=create_users_table
```

## Code Quality

### 1. Linting and Formatting
- Use `golangci-lint` for linting
- Format code with `go fmt`
- Run `go vet` for static analysis
- Use consistent import ordering

### 2. Documentation
- Document all public APIs
- Use godoc comments for packages
- Keep README files updated
- Document configuration options

### 3. Security
- Validate all inputs
- Use prepared statements for database queries
- Implement proper authentication and authorization
- Use HTTPS in production
- Follow OWASP guidelines

## Best Practices

### 1. Code Organization
- Keep related code together
- Use meaningful package names
- Avoid circular dependencies
- Keep functions small and focused

### 2. Error Handling
- Always check errors
- Provide meaningful error messages
- Use custom error types for domain errors
- Log errors with context

### 3. Testing
- Write tests first (TDD when possible)
- Use table-driven tests
- Mock external dependencies
- Test error conditions

### 4. Documentation
- Document public APIs
- Keep examples up to date
- Document configuration options
- Maintain architecture documentation

## Common Patterns

### 1. Repository Pattern
```go
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    GetByID(ctx context.Context, id string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id string) error
}
```

### 2. Service Pattern
```go
type UserService interface {
    CreateUser(ctx context.Context, req CreateUserRequest) (*User, error)
    GetUser(ctx context.Context, id string) (*User, error)
    UpdateUser(ctx context.Context, req UpdateUserRequest) (*User, error)
}
```

### 3. Handler Pattern
```go
type UserHandler struct {
    userService UserService
    logger      *zap.Logger
}

func (h *UserHandler) CreateUser(c *gin.Context) {
    // Handle HTTP request
    // Validate input
    // Call service
    // Return response
}
```
# Development Guidelines

## Code Style and Conventions

### 1. Naming Conventions

#### Packages
- Use lowercase, single word
- Avoid underscores or mixed case
- Be descriptive but concise

```go
// ✅ GOOD
package user
package auth
package config

// ❌ BAD
package UserService
package user_service
package userService
```

#### Files
- Use snake_case for file names
- Be descriptive and indicate purpose

```go
// ✅ GOOD
user_repository.go
auth_middleware.go
config_database.go

// ❌ BAD
userRepo.go
authMiddleware.go
configDB.go
```

#### Functions
- Use camelCase, descriptive names
- Use verb-noun format for actions
- Be clear about what the function does

```go
// ✅ GOOD
func CreateUser(ctx context.Context, user *User) error
func GetUserByID(ctx context.Context, id string) (*User, error)
func ValidateEmail(email string) error

// ❌ BAD
func create(ctx context.Context, u *User) error
func getUser(ctx context.Context, id string) (*User, error)
func validate(e string) error
```

#### Variables
- Use camelCase, descriptive names
- Avoid single letter variables (except in loops)
- Use meaningful names that indicate purpose

```go
// ✅ GOOD
userID := "123"
emailAddress := "user@example.com"
maxRetries := 3

// ❌ BAD
id := "123"
email := "user@example.com"
retries := 3
```

#### Constants
- Use UPPER_SNAKE_CASE
- Group related constants together

```go
// ✅ GOOD
const (
    MaxRetries = 3
    DefaultTimeout = 30 * time.Second
    CacheTTL = 5 * time.Minute
)
```

#### Interfaces
- Use descriptive names ending with -er
- Indicate the capability or behavior

```go
// ✅ GOOD
type UserRepository interface { ... }
type EmailService interface { ... }
type Logger interface { ... }

// ❌ BAD
type UserRepo interface { ... }
type Email interface { ... }
type Log interface { ... }
```

#### Structs
- Use PascalCase, descriptive names
- Indicate the purpose or domain concept

```go
// ✅ GOOD
type User struct { ... }
type CreateUserRequest struct { ... }
type DatabaseConfig struct { ... }

// ❌ BAD
type user struct { ... }
type createUserReq struct { ... }
type dbConfig struct { ... }
```

### 2. File Organization

#### Service Structure
Each service follows an enhanced layered architecture with CQRS support:

```
{service-name}/
├── domain/                    # Pure business rules
│   ├── entity/                # Core entities (Account, Role, etc)
│   ├── repository/            # Abstract interfaces (ports)
│   ├── service/               # Domain service logic (pure functions)
│   └── types/                 # Value objects, enums, primitives
│
├── application/              # Use case orchestration (commands/queries)
│   ├── {subdomain}/          # E.g. account/, role/, etc
│       ├── command.go
│       ├── query.go
│       └── dto.go
│
├── delivery/                 # Controller / handler layer
│   └── http/                 # HTTP handlers & routing
│       ├── handler.go
│       ├── router.go
│       └── middleware.go
│
├── infrastructure/           # Adapter layer (DB, cache, etc)
│   ├── postgres/             # DB repositories
│   ├── redis/                # Cache layer
│   ├── emailservice/         # External service clients
│   └── persistence.go        # Optional DB setup logic
│
├── config/                   # Service-specific config structures
│   └── config.go
│
├── init/                     # Service initialization logic (DI wiring)
│   └── init.go
│
└── module.go                 # Optional facade to expose
```

#### Package Organization
- Keep related code together
- Use meaningful package names
- Avoid circular dependencies
- Keep functions small and focused

### 3. Error Handling

#### Error Types
- Use structured errors with context
- Return errors from lower layers
- Log errors at the delivery layer
- Use custom error types for domain errors

```go
// ✅ GOOD: Custom domain error
type UserNotFoundError struct {
    UserID string
}

func (e UserNotFoundError) Error() string {
    return fmt.Sprintf("user not found: %s", e.UserID)
}

// ✅ GOOD: Error wrapping
if err != nil {
    return fmt.Errorf("failed to create user: %w", err)
}
```

#### Error Checking
- Always check errors and handle them appropriately
- Don't ignore errors
- Provide meaningful error messages

```go
// ✅ GOOD
user, err := repo.GetUser(ctx, userID)
if err != nil {
    return fmt.Errorf("failed to get user %s: %w", userID, err)
}

// ❌ BAD
user, _ := repo.GetUser(ctx, userID)
```

### 4. Logging

#### Structured Logging
Use structured logging with context:

```go
// ✅ GOOD
logger.Info("User created",
    zap.String("user_id", user.ID),
    zap.String("email", user.Email),
    zap.String("method", "CreateUser"),
)

logger.Error("Failed to create user",
    zap.String("user_id", userID),
    zap.Error(err),
    zap.String("method", "CreateUser"),
)
```

#### Log Levels
- **DEBUG**: Detailed information for debugging
- **INFO**: General information about application flow
- **WARN**: Warning messages for potential issues
- **ERROR**: Error messages for actual problems
- **FATAL**: Critical errors that require immediate attention

### 5. Configuration

#### Configuration Management
- Use Viper for configuration management
- Support multiple config sources (env vars, files, etc.)
- Use environment-specific config files
- Validate configuration on startup

```go
// ✅ GOOD: Configuration structure
type Config struct {
    Database DatabaseConfig `mapstructure:"database"`
    Server   ServerConfig   `mapstructure:"server"`
    Redis    RedisConfig    `mapstructure:"redis"`
}

type DatabaseConfig struct {
    Host     string `mapstructure:"host"`
    Port     int    `mapstructure:"port"`
    Username string `mapstructure:"username"`
    Password string `mapstructure:"password"`
    Database string `mapstructure:"database"`
}
```

### 6. Dependency Injection

#### DI Container Usage
- Use the bootstrap container for DI
- Register services in the container
- Use interfaces for dependencies
- Make testing easier with DI

```go
// ✅ GOOD: Service registration
container.Register("userRepository", func() UserRepository {
    return NewPostgreSQLUserRepository(db)
})

container.Register("userService", func() UserService {
    repo := container.Get("userRepository").(UserRepository)
    return NewUserService(repo)
})
```

## Development Guidelines

### 1. Service Creation
When creating a new service:
1. Use the template script: `./scripts/create.sh service <service-name>`
2. Follow the enhanced layered architecture pattern with CQRS support
3. Start with domain entities and business rules
4. Add application layer with commands and queries
5. Implement infrastructure layer (database, external APIs)
6. Add delivery layer (HTTP handlers, gRPC services)

#### Creating Subdomains
To add a new subdomain to an existing service:
```bash
./scripts/create.sh subdomain <subdomain-name> <service-name>
```

This will create:
- `application/{subdomain}/command.go`
- `application/{subdomain}/query.go`
- `application/{subdomain}/dto.go`

### 2. Testing Strategy
- **Unit Tests**: Test each layer independently with mocks
- **Integration Tests**: Test service interactions with test database
- **Performance Tests**: Use benchmarks for critical paths
- **Coverage**: Aim for 80%+ test coverage

### 3. Database
- Use PostgreSQL as primary database
- Use migrations for schema changes
- Follow naming conventions for tables and columns
- Use transactions for data consistency
- Implement proper indexing strategies

### 4. API Design
- Use RESTful principles
- Version APIs properly (/api/v1/)
- Use consistent error responses
- Implement proper validation
- Add comprehensive documentation

## Common Commands

### Development
```bash
# Setup environment
make setup

# Build application
make build

# Run main server
make run

# Run worker
make run-worker

# Run tests
make test

# Create new service
make create-service NAME=user-service
```

### Docker
```bash
# Build and run with Docker
make docker-build
make docker-run

# Development environment
make dev
make dev-stop
```

### Database
```bash
# Run migrations
make migrate-up
make migrate-down

# Create new migration
make migrate-create NAME=create_users_table
```

## Code Quality

### 1. Linting and Formatting
- Use `golangci-lint` for linting
- Format code with `go fmt`
- Run `go vet` for static analysis
- Use consistent import ordering

### 2. Documentation
- Document all public APIs
- Use godoc comments for packages
- Keep README files updated
- Document configuration options

### 3. Security
- Validate all inputs
- Use prepared statements for database queries
- Implement proper authentication and authorization
- Use HTTPS in production
- Follow OWASP guidelines

## Best Practices

### 1. Code Organization
- Keep related code together
- Use meaningful package names
- Avoid circular dependencies
- Keep functions small and focused

### 2. Error Handling
- Always check errors
- Provide meaningful error messages
- Use custom error types for domain errors
- Log errors with context

### 3. Testing
- Write tests first (TDD when possible)
- Use table-driven tests
- Mock external dependencies
- Test error conditions

### 4. Documentation
- Document public APIs
- Keep examples up to date
- Document configuration options
- Maintain architecture documentation

## Common Patterns

### 1. Repository Pattern
```go
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    GetByID(ctx context.Context, id string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id string) error
}
```

### 2. Service Pattern
```go
type UserService interface {
    CreateUser(ctx context.Context, req CreateUserRequest) (*User, error)
    GetUser(ctx context.Context, id string) (*User, error)
    UpdateUser(ctx context.Context, req UpdateUserRequest) (*User, error)
}
```

### 3. Handler Pattern
```go
type UserHandler struct {
    userService UserService
    logger      *zap.Logger
}

func (h *UserHandler) CreateUser(c *gin.Context) {
    // Handle HTTP request
    // Validate input
    // Call service
    // Return response
}
```
